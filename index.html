<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>익명 랜덤 채팅</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* 커스텀 스크롤바 스타일 */
        #messages-container::-webkit-scrollbar {
            width: 8px;
        }
        #messages-container::-webkit-scrollbar-thumb {
            background-color: #a0aec0; /* gray-400 */
            border-radius: 4px;
        }
        #messages-container::-webkit-scrollbar-track {
            background-color: #edf2f7; /* gray-200 */
        }

        /* 폰트 설정 (Inter 폰트가 없는 환경을 위해 fallback) */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* 메시지 애니메이션 */
        .message-enter-active, .message-leave-active {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .message-enter-from, .message-leave-to {
            opacity: 0;
            transform: translateY(10px);
        }

    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'secondary': '#6366f1',
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div id="chat-app" class="w-full max-w-md bg-white shadow-2xl rounded-xl flex flex-col h-[85vh] overflow-hidden">
        
        <!-- Header: 접속자 수 표시 추가 -->
        <header class="p-4 bg-primary text-white rounded-t-xl shadow-lg flex justify-between items-center">
            <h1 class="text-xl font-bold">익명 랜덤 채팅 ??</h1>
            <div class="flex space-x-3 items-center">
                <!-- 접속자 수 표시 -->
                <span id="active-users-display" class="text-xs bg-indigo-500 px-2 py-1 rounded-full opacity-90 font-medium">
                    접속자: 0
                </span>
                <span id="user-id-display" class="text-xs bg-secondary px-2 py-1 rounded-full opacity-75">Loading...</span>
            </div>
        </header>

        <!-- Status & Main Content -->
        <main class="flex-grow flex flex-col p-4 space-y-4 overflow-hidden">
            
            <!-- Status Display -->
            <div id="status-display" class="bg-yellow-100 border border-yellow-300 text-yellow-800 p-3 rounded-lg text-sm text-center font-medium transition duration-300">
                Firebase 로딩 중...
            </div>

            <!-- Chat Area (Hidden until matched) -->
            <div id="chat-area" class="flex-grow flex flex-col space-y-3 overflow-y-auto hidden">
                <div id="messages-container" class="flex-grow space-y-3 overflow-y-auto p-2 bg-gray-50 rounded-lg shadow-inner">
                    <!-- Messages will be injected here -->
                </div>
            </div>

            <!-- Matching/Disconnect Buttons -->
            <div id="controls-area" class="flex flex-col space-y-2">
                <!-- 버튼 문구를 '대화 시작'으로 변경하고 아이콘 변경 -->
                <button id="match-button" 
                        class="bg-primary hover:bg-secondary text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-200 disabled:opacity-50 flex items-center justify-center"
                        disabled>
                    <i class="fas fa-comment-dots mr-2"></i> 대화 시작
                </button>
                <button id="disconnect-button" 
                        class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-200 hidden">
                    <i class="fas fa-times-circle mr-2"></i> 다음 사람 찾기 (대화 종료)
                </button>
            </div>

        </main>

        <!-- Input Area (Hidden until matched) -->
        <footer id="input-area" class="p-4 border-t border-gray-200 bg-white hidden">
            <div class="flex space-x-2">
                <input type="text" id="message-input" placeholder="메시지를 입력하세요..."
                       class="flex-grow border border-gray-300 p-3 rounded-xl focus:ring-2 focus:ring-primary focus:border-primary transition duration-150"
                       maxlength="500">
                <button id="send-button"
                        class="bg-primary hover:bg-secondary text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-200 disabled:opacity-50">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </footer>

    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, 
            setPersistence, browserSessionPersistence
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, 
            collection, query, where, addDoc, getDocs, limit, orderBy, runTransaction, serverTimestamp, setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestore 로그 레벨 설정 (디버깅용)
        setLogLevel('Debug'); 

        // 전역 변수 초기화
        let app;
        let db;
        let auth;
        let userId = 'anonymous';
        let currentLobbyId = null;
        let unsubscribeChat = null;
        let isAuthReady = false;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-chat-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // DOM 요소 캐시
        const statusDisplay = document.getElementById('status-display');
        const matchButton = document.getElementById('match-button');
        const disconnectButton = document.getElementById('disconnect-button');
        const chatArea = document.getElementById('chat-area');
        const inputArea = document.getElementById('input-area');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const userIdDisplay = document.getElementById('user-id-display');
        const activeUsersDisplay = document.getElementById('active-users-display'); // 접속자 수 DOM 요소

        /**
         * 상태 메시지를 업데이트하고 UI를 변경합니다.
         * @param {string} message - 표시할 메시지
         * @param {string} type - 'info', 'waiting', 'matched', 'error'
         */
        function updateStatus(message, type = 'info') {
            statusDisplay.textContent = message;
            statusDisplay.className = 'p-3 rounded-xl text-sm text-center font-medium transition duration-300';
            
            switch (type) {
                case 'waiting':
                    statusDisplay.classList.add('bg-blue-100', 'border', 'border-blue-300', 'text-blue-800');
                    break;
                case 'matched':
                    statusDisplay.classList.add('bg-green-100', 'border', 'border-green-300', 'text-green-800');
                    break;
                case 'error':
                    statusDisplay.classList.add('bg-red-100', 'border', 'border-red-300', 'text-red-800');
                    break;
                case 'info':
                default:
                    statusDisplay.classList.add('bg-yellow-100', 'border', 'border-yellow-300', 'text-yellow-800');
                    break;
            }
        }

        /**
         * 채팅 UI의 표시 상태를 업데이트합니다.
         * @param {boolean} isMatched - 매칭 상태 여부
         */
        function updateChatUI(isMatched) {
            matchButton.classList.toggle('hidden', isMatched);
            disconnectButton.classList.toggle('hidden', !isMatched);
            chatArea.classList.toggle('hidden', !isMatched);
            inputArea.classList.toggle('hidden', !isMatched);
            if (isMatched) {
                // 매칭되면 대기 상태 메시지를 숨김
                statusDisplay.classList.add('hidden');
            } else {
                // 매칭이 해제되면 메시지 창 비우고 상태 메시지 표시
                statusDisplay.classList.remove('hidden');
                messagesContainer.innerHTML = '';
            }
            messageInput.value = ''; // 입력 필드 초기화
        }

        /**
         * Firestore 인증 및 초기 설정을 수행합니다.
         */
        async function setupFirebase() {
            if (!firebaseConfig) {
                updateStatus('오류: Firebase 설정 정보를 찾을 수 없습니다.', 'error');
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // 세션 동안 인증 상태 유지
                await setPersistence(auth, browserSessionPersistence);
                
                // 사용자 인증 처리
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userIdDisplay.textContent = `내 ID: ${userId.substring(0, 8)}...`;
                        isAuthReady = true;
                        // 상태 메시지를 '대화 시작' 버튼에 맞춰 변경
                        updateStatus('인증 완료. 아래 버튼을 눌러 대화를 시작하세요!', 'info');
                        matchButton.disabled = false;
                        matchButton.onclick = matchUser; // 인증 완료 후 이벤트 리스너 설정
                        
                        // **[새 기능]** 접속자 리스너 시작
                        startActiveUsersListener(); 

                    } else {
                        updateStatus('인증 실패. 다시 시도해 주세요.', 'error');
                        matchButton.disabled = true;
                    }
                });

            } catch (error) {
                console.error("Firebase 초기화 또는 인증 오류:", error);
                updateStatus(`Firebase 오류: ${error.message}`, 'error');
            }
        }
        
        /**
         * **[새 기능]** 로비 컬렉션을 감시하여 현재 접속자 수를 계산하고 표시합니다.
         * 'waiting' 로비는 1명, 'matched' 로비는 2명으로 간주합니다.
         */
        function startActiveUsersListener() {
            if (!db) return;
            const lobbiesRef = collection(db, 'artifacts', appId, 'public/data', 'lobbies');
            
            // 전체 로비 컬렉션을 감시합니다.
            onSnapshot(lobbiesRef, (snapshot) => {
                let activeUserCount = 0;
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.status === 'waiting') {
                        // 대기 중인 로비는 1명의 사용자
                        activeUserCount += 1;
                    } else if (data.status === 'matched' && data.user2Id) {
                        // 매칭된 로비는 2명의 사용자
                        activeUserCount += 2;
                    }
                });
                activeUsersDisplay.textContent = `접속자: ${activeUserCount}`;
            }, (error) => {
                console.error("Active Users Listener Error:", error);
                activeUsersDisplay.textContent = `접속자: N/A`;
            });
        }


        /**
         * 대화 메시지를 렌더링합니다.
         * @param {Object[]} messages - 메시지 객체 배열
         */
        function renderMessages(messages) {
            messagesContainer.innerHTML = '';
            messages.forEach(msg => {
                const isMine = msg.senderId === userId;
                const alignment = isMine ? 'justify-end' : 'justify-start';
                const bgColor = isMine ? 'bg-secondary text-white' : 'bg-gray-200 text-gray-800';

                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${alignment} message-enter-active message-enter-from`;
                
                const bubble = document.createElement('div');
                bubble.className = `${bgColor} p-3 rounded-xl max-w-[80%] break-words shadow-sm`;
                bubble.textContent = msg.text;

                messageDiv.appendChild(bubble);
                messagesContainer.appendChild(messageDiv);
            });
            // 스크롤을 맨 아래로 이동
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        /**
         * 채팅방 메시지 변화를 실시간으로 감지합니다.
         * @param {string} lobbyId - 현재 로비 ID
         */
        function startChatListener(lobbyId) {
            if (unsubscribeChat) {
                unsubscribeChat();
            }

            const chatRef = doc(db, 'artifacts', appId, 'public/data', 'chats', lobbyId);

            unsubscribeChat = onSnapshot(chatRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // 메시지 배열이 있고, 배열이 아닌 경우를 대비해 확인
                    const messages = Array.isArray(data.messages) ? data.messages : [];
                    renderMessages(messages);
                } else {
                    // 채팅방이 삭제됨 (상대방이 나갔거나 오류)
                    console.log("Chat document not found. Ending match.");
                    handleDisconnection(false); // 상대방이 나간 것으로 처리
                }
            }, (error) => {
                console.error("Chat Listener Error:", error);
                handleDisconnection(false);
            });
        }

        /**
         * 무작위 대화 상대를 찾거나 새로운 대기열을 만듭니다.
         */
        async function matchUser() {
            if (!isAuthReady) return;

            updateStatus('대화 상대를 찾는 중입니다...', 'waiting');
            matchButton.disabled = true;

            const lobbiesRef = collection(db, 'artifacts', appId, 'public/data', 'lobbies');

            try {
                // 1. 대기 중인 로비 찾기
                const waitingQuery = query(
                    lobbiesRef, 
                    where('status', '==', 'waiting'), 
                    where('user1Id', '!=', userId), // 본인이 만든 로비는 제외
                    orderBy('createdAt'), 
                    limit(1)
                );
                
                const snapshot = await getDocs(waitingQuery);

                if (!snapshot.empty) {
                    // 2. 대기 중인 로비가 있으면 참여 (트랜잭션을 사용하여 동시성 문제 방지)
                    const waitingDocRef = snapshot.docs[0].ref;
                    const lobbyId = waitingDocRef.id;

                    await runTransaction(db, async (transaction) => {
                        const doc = await transaction.get(waitingDocRef);
                        
                        if (doc.exists() && doc.data().status === 'waiting' && doc.data().user1Id !== userId) {
                            // 로비 참여
                            transaction.update(waitingDocRef, {
                                status: 'matched',
                                user2Id: userId,
                                matchedAt: serverTimestamp()
                            });
                            
                            // 채팅방 생성 (로비 ID와 동일하게 설정)
                            const chatRef = doc(db, 'artifacts', appId, 'public/data', 'chats', lobbyId);
                            transaction.set(chatRef, { 
                                participants: [doc.data().user1Id, userId],
                                messages: [{
                                    senderId: 'SYSTEM',
                                    text: '대화가 시작되었습니다. 서로에게 인사해보세요!',
                                    // timestamp는 onSnapshot에서 처리되므로 여기서는 임시 값 사용
                                    timestamp: new Date().toISOString() 
                                }],
                                startedAt: serverTimestamp()
                            });
                            currentLobbyId = lobbyId;
                            updateStatus('대화 상대와 연결되었습니다! ??', 'matched');
                        } else {
                            // 이미 다른 사용자가 참여했거나 조건 불일치
                            currentLobbyId = null; // 실패로 간주하고 새 로비 생성 로직으로 다시 시도 가능
                            throw new Error("Lobby claimed or invalid.");
                        }
                    });

                    if (currentLobbyId) {
                        startChatListener(currentLobbyId);
                        updateChatUI(true);
                    } else {
                        // 트랜잭션 실패 시 재시도 또는 새 로비 생성 로직으로 진행
                        throw new Error("Failed to join lobby.");
                    }

                } else {
                    // 3. 대기 중인 로비가 없으면 새로운 로비 생성
                    const newLobbyRef = doc(lobbiesRef);
                    currentLobbyId = newLobbyRef.id;

                    await setDoc(newLobbyRef, {
                        status: 'waiting',
                        user1Id: userId,
                        createdAt: serverTimestamp(),
                        appId: appId // 추가 메타데이터
                    });
                    
                    updateStatus('대기열에 등록되었습니다. 상대방을 기다리는 중...', 'waiting');
                    updateChatUI(false);

                    // 본인이 만든 로비를 관찰하며 상대방이 매칭되는지 확인
                    const unsubscribeLobby = onSnapshot(newLobbyRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.status === 'matched' && data.user2Id) {
                                // 매칭 성공!
                                if (unsubscribeChat) {
                                    unsubscribeChat();
                                }
                                startChatListener(currentLobbyId);
                                updateStatus('대화 상대와 연결되었습니다! ??', 'matched');
                                updateChatUI(true);
                                // 로비 리스너 해제 (매칭이 되면 더 이상 필요 없음)
                                unsubscribeLobby(); 
                            }
                        } else {
                            // 로비가 삭제됨 (오류 또는 상대방의 나가기)
                            if (currentLobbyId) {
                                // 로비 리스너 해제 후 연결 해제 처리
                                unsubscribeLobby();
                                handleDisconnection(false, "로비가 사라졌습니다. 다시 시도해 주세요.");
                            }
                        }
                    }, (error) => {
                        console.error("Lobby Listener Error:", error);
                        // 오류 발생 시 연결 해제
                        handleDisconnection(false);
                    });
                }

            } catch (error) {
                console.warn("Matching Error (Attempting to re-queue):", error.message);
                updateStatus('대화 상대를 찾지 못했습니다. 다시 시도해 주세요.', 'error');
                matchButton.disabled = false;
                currentLobbyId = null; // 상태 초기화
            }
        }

        /**
         * 메시지를 전송합니다.
         */
        async function sendMessage() {
            if (!currentLobbyId || !messageInput.value.trim()) return;

            const text = messageInput.value.trim();
            messageInput.value = '';
            sendButton.disabled = true;

            const chatRef = doc(db, 'artifacts', appId, 'public/data', 'chats', currentLobbyId);
            
            const newMessage = {
                senderId: userId,
                text: text,
                // 클라이언트에서 타임스탬프를 넣어주어 즉각적인 UI 반영을 돕습니다.
                timestamp: Date.now() 
            };
            
            try {
                // 트랜잭션을 사용하여 메시지 배열에 안전하게 추가
                await runTransaction(db, async (transaction) => {
                    const chatDoc = await transaction.get(chatRef);
                    if (!chatDoc.exists()) {
                        throw "Chat document does not exist, cannot send message!";
                    }

                    // 메시지 배열을 안전하게 가져옴
                    const currentMessages = Array.isArray(chatDoc.data().messages) ? chatDoc.data().messages : [];
                    
                    // Firestore에 저장할 객체: 클라이언트 타임스탬프(ISO 문자열) 사용
                    const serverSafeMessage = { ...newMessage, timestamp: new Date().toISOString() };
                    
                    const updatedMessages = [...currentMessages, serverSafeMessage];
                    
                    // 메시지 배열 업데이트
                    transaction.update(chatRef, { 
                        messages: updatedMessages
                    });
                });

            } catch (error) {
                console.error("메시지 전송 트랜잭션 오류:", error);
                // 오류 메시지 대신 콘솔에 출력
            } finally {
                sendButton.disabled = false;
            }
        }

        /**
         * 대화를 종료하고 로비를 정리합니다.
         * @param {boolean} selfInitiated - 사용자가 버튼을 눌러 종료했는지 여부
         * @param {string} customMessage - 사용자 지정 상태 메시지
         */
        async function handleDisconnection(selfInitiated = true, customMessage = null) {
            if (!currentLobbyId) {
                updateStatus('새 대화를 시작할 수 있습니다.', 'info');
                updateChatUI(false);
                matchButton.disabled = false;
                return;
            }

            // 실시간 리스너 해제
            if (unsubscribeChat) {
                unsubscribeChat();
                unsubscribeChat = null;
            }

            const lobbyId = currentLobbyId;
            currentLobbyId = null; // 상태 초기화
            
            const lobbyRef = doc(db, 'artifacts', appId, 'public/data', 'lobbies', lobbyId);
            const chatRef = doc(db, 'artifacts', appId, 'public/data', 'chats', lobbyId);

            try {
                // 로비 및 채팅 문서 삭제
                await deleteDoc(lobbyRef);
                await deleteDoc(chatRef);
                console.log(`Lobby/Chat ${lobbyId} deleted.`);
            } catch (error) {
                console.error("Lobby/Chat 삭제 오류:", error);
            }

            const statusMsg = selfInitiated 
                ? '대화가 종료되었습니다. 다음 사람을 찾아보세요! ??' 
                : (customMessage || '상대방이 연결을 끊었습니다. 다음 사람을 찾아보세요! ??');
            
            updateStatus(statusMsg, 'info');
            updateChatUI(false);
            matchButton.disabled = false;
        }

        // 이벤트 리스너 설정
        window.onload = () => {
            setupFirebase();
            
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            sendButton.onclick = sendMessage;
            disconnectButton.onclick = () => handleDisconnection(true);
            
            // 초기 UI 상태는 매칭되지 않은 상태
            updateChatUI(false);
        };
        
    </script>
</body>
</html>
